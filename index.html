<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFC Structure Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to bottom, #0a0e27 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #333;
            position: relative;
            overflow-x: hidden;
        }

        .stars-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle linear infinite, moveStar linear infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }

        @keyframes moveStar {
            0% { transform: translate(0, 0); }
            100% { transform: translate(-100px, 100px); }
        }

        nav {
            background: rgba(30, 58, 138, 0.85);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0,0,0,0.3);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .nav-container {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
        }
        
        .logo {
            color: white;
            font-size: 24px;
            font-weight: bold;
            padding: 15px 0;
        }
        
        .nav-menu {
            display: flex;
            list-style: none;
            gap: 0;
        }
        
        .nav-menu li a {
            color: white;
            text-decoration: none;
            padding: 20px 25px;
            display: block;
            transition: background 0.3s;
        }
        
        .nav-menu li a:hover {
            background: rgba(255,255,255,0.1);
        }

        .page-wrapper {
            max-width: 1800px;
            margin: 0 auto;
            padding: 30px 20px;
            position: relative;
            z-index: 1;
        }

        .canvas-wrapper {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            border: 3px solid #3b82f6;
            backdrop-filter: blur(10px);
            margin-bottom: 30px;
            position: relative;
        }
        
        #container {
            width: 100%;
            height: 900px;
            position: relative;
            background: #f8fafc;
        }

        #container.dark-canvas {
            background: #1a1a1a;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .canvas-bg-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 12px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .canvas-bg-label {
            color: #1e293b;
            font-weight: 600;
            font-size: 13px;
        }

        #container.dark-canvas .canvas-bg-label {
            color: white;
        }

        .layers-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            width: 280px;
            max-height: 800px;
            overflow-y: auto;
        }

        #container.dark-canvas .layers-panel {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .layers-panel h3 {
            color: #1e3a8a;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 8px;
        }

        #container.dark-canvas .layers-panel h3 {
            color: #93c5fd;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(229, 231, 235, 0.3);
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            margin-right: 12px;
            flex-shrink: 0;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(203, 213, 225, 0.5);
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #3b82f6;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .layer-label {
            font-size: 14px;
            color: #374151;
            font-weight: 500;
        }

        #container.dark-canvas .layer-label {
            color: #e5e7eb;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #1e293b;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-width: 240px;
            pointer-events: none;
        }

        #container.dark-canvas #controls {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #controls h4 {
            margin: 0 0 8px 0;
            color: #1e3a8a;
            font-size: 14px;
            font-weight: bold;
        }

        #container.dark-canvas #controls h4 {
            color: #93c5fd;
        }
        
        .control-item {
            margin: 5px 0;
            font-size: 11px;
            line-height: 1.4;
        }
        
        .control-label {
            font-weight: bold;
            color: #0f172a;
            display: inline-block;
            min-width: 75px;
        }

        #container.dark-canvas .control-label {
            color: #e0e7ff;
        }

        #container.dark-canvas .control-item {
            color: #cbd5e1;
        }

        .about-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }
        
        .about-section h3 {
            color: #1e3a8a;
            margin-bottom: 20px;
            font-size: 24px;
            border-bottom: 3px solid #3b82f6;
            padding-bottom: 12px;
        }
        
        .about-section p {
            color: #475569;
            line-height: 1.8;
            font-size: 15px;
            margin-bottom: 25px;
        }

        .project-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 8px;
            color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .stat-label {
            font-size: 13px;
            opacity: 0.9;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        footer {
            background: rgba(30, 58, 138, 0.85);
            backdrop-filter: blur(10px);
            color: white;
            padding: 40px 20px 20px;
            margin-top: 50px;
            box-shadow: 0 -2px 20px rgba(0,0,0,0.3);
        }
        
        .footer-content {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .footer-section h4 {
            color: #93c5fd;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .footer-section ul {
            list-style: none;
        }
        
        .footer-section ul li {
            margin: 8px 0;
        }
        
        .footer-section a {
            color: #e0e7ff;
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .footer-section a:hover {
            color: #93c5fd;
        }
        
        .footer-bottom {
            max-width: 1800px;
            margin: 0 auto;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            text-align: center;
            color: #93c5fd;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            #container {
                height: 600px;
            }
            
            .layers-panel {
                width: 220px;
                max-height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="stars-container" id="starsContainer"></div>

    <nav>
        <div class="nav-container">
            <div class="logo">IFC Viewer</div>
            <ul class="nav-menu">
                <li><a href="#home">Home</a></li>
                <li><a href="#projects">Projects</a></li>
                <li><a href="#about">About</a></li>
            </ul>
        </div>
    </nav>

    <div class="page-wrapper">
        <div class="canvas-wrapper">
            <div id="container">
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="loading-content">
                        <div class="loading-spinner"></div>
                        <div>Loading IFC Model...</div>
                    </div>
                </div>

                <div class="canvas-bg-toggle">
                    <span class="canvas-bg-label">Canvas BG</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="canvasBgToggle" onchange="toggleCanvasBackground()">
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="layers-panel" id="layersPanel">
                    <h3>Layers</h3>
                    <div id="layersList"></div>
                </div>

                <canvas id="canvas"></canvas>
                
                <div id="controls">
                    <h4>View Controls</h4>
                    <div class="control-item">
                        <span class="control-label">Rotate:</span> Left Click + Drag
                    </div>
                    <div class="control-item">
                        <span class="control-label">Pan:</span> Right Click + Drag
                    </div>
                    <div class="control-item">
                        <span class="control-label">Zoom:</span> Mouse Scroll
                    </div>
                    <div class="control-item">
                        <span class="control-label">Navigate:</span> WASD / Arrows
                    </div>
                    <div class="control-item">
                        <span class="control-label">Vertical:</span> Space / Shift
                    </div>
                </div>
            </div>
        </div>

        <div class="about-section" id="aboutSection">
            <h3>IFC Structure Analysis</h3>
            <p id="aboutText">Loading structure information...</p>
            
            <div class="project-stats" id="projectStats">
            </div>
        </div>
    </div>

    <footer>
        <div class="footer-content">
            <div class="footer-section">
                <h4>About</h4>
                <ul>
                    <li><a href="#about">About Us</a></li>
                    <li><a href="#contact">Contact</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="#docs">Documentation</a></li>
                    <li><a href="#support">Support</a></li>
                </ul>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2025 IFC Viewer. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let ifcData = { columns: [], beams: [] };
        let scene, camera, renderer;
        let structure;
        let columnsGroup, beamsGroup, gridHelper;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isDragging = false;
        let isPanning = false;
        let cameraTarget = new THREE.Vector3(3, 2, 2.5);
        let cameraPan = new THREE.Vector3(3, 2, 2.5);
        
        let keys = {};
        let moveSpeed = 0.1;
        let verticalSpeed = 0.1;
        let canvasHasFocus = false;

        // IFC Parser
        async function loadAndParseIFC() {
            try {
                const response = await fetch('model.ifc');
                const ifcText = await response.text();
                
                const entities = parseIFCFile(ifcText);
                ifcData = extractStructuralData(entities);
                
                updateUI();
                hideLoading();
                init();
            } catch (error) {
                console.error('Error loading IFC file:', error);
                document.getElementById('loadingOverlay').innerHTML = 
                    '<div class="loading-content"><div style="color: #ff6b6b; font-size: 18px;">Error loading model.ifc<br>Please ensure the file exists in the same directory.</div></div>';
            }
        }

        function parseIFCFile(ifcText) {
            const entities = {};
            const lines = ifcText.split('\n');
            
            for (const line of lines) {
                const match = line.match(/#(\d+)=(\w+)\((.*)\);?/);
                if (match) {
                    const [, id, type, params] = match;
                    entities[id] = { id, type, params: parseParams(params), raw: line };
                }
            }
            
            return entities;
        }

        function parseParams(paramString) {
            const params = [];
            let current = '';
            let depth = 0;
            let inString = false;
            
            for (let i = 0; i < paramString.length; i++) {
                const char = paramString[i];
                
                if (char === "'" && paramString[i-1] !== '\\') {
                    inString = !inString;
                    current += char;
                } else if (inString) {
                    current += char;
                } else if (char === '(') {
                    depth++;
                    current += char;
                } else if (char === ')') {
                    depth--;
                    current += char;
                } else if (char === ',' && depth === 0) {
                    params.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            if (current.trim()) {
                params.push(current.trim());
            }
            
            return params;
        }

        function extractStructuralData(entities) {
            const columns = [];
            const beams = [];
            
            for (const id in entities) {
                const entity = entities[id];
                
                if (entity.type === 'IFCCOLUMNSTANDARDCASE' || entity.type === 'IFCCOLUMN') {
                    const columnData = extractElementData(entity, entities, 'column');
                    if (columnData) columns.push(columnData);
                }
                
                if (entity.type === 'IFCBEAMSTANDARDCASE' || entity.type === 'IFCBEAM') {
                    const beamData = extractElementData(entity, entities, 'beam');
                    if (beamData) beams.push(beamData);
                }
            }
            
            return { columns, beams };
        }

        function extractElementData(element, entities, type) {
            try {
                const nameMatch = element.params[2]?.match(/'([^']+)'/);
                const name = nameMatch ? nameMatch[1] : element.id;
                
                const placementRef = element.params[5]?.match(/#(\d+)/)?.[1];
                const shapeRef = element.params[6]?.match(/#(\d+)/)?.[1];
                
                if (!placementRef || !shapeRef) return null;
                
                const placement = entities[placementRef];
                const shape = entities[shapeRef];
                
                const axisRef = placement.params[1]?.match(/#(\d+)/)?.[1];
                const axis = entities[axisRef];
                
                const originRef = axis.params[0]?.match(/#(\d+)/)?.[1];
                const directionRef = axis.params[1]?.match(/#(\d+)/)?.[1];
                const origin = entities[originRef];
                const direction = entities[directionRef];
                
                const originCoords = parseCoordinates(origin.params);
                const directionVec = parseCoordinates(direction.params);
                
                const representations = shape.params[3]?.match(/#(\d+)/g) || [];
                let extrudeLength = 0;
                let profile = null;
                
                for (const repRef of representations) {
                    const rep = entities[repRef.substring(1)];
                    if (!rep) continue;
                    
                    const items = rep.params[3]?.match(/#(\d+)/g) || [];
                    for (const itemRef of items) {
                        const item = entities[itemRef.substring(1)];
                        if (item && item.type === 'IFCEXTRUDEDAREASOLID') {
                            extrudeLength = parseFloat(item.params[3]) / 100;
                            
                            const profileRef = item.params[0]?.match(/#(\d+)/)?.[1];
                            if (profileRef) {
                                profile = parseProfile(entities[profileRef]);
                            }
                        }
                    }
                }
                
                if (!profile || extrudeLength === 0) return null;
                
                const start = [
                    originCoords[0] / 100,
                    originCoords[1] / 100,
                    originCoords[2] / 100
                ];
                
                const end = [
                    start[0] + (directionVec[0] * extrudeLength),
                    start[1] + (directionVec[1] * extrudeLength),
                    start[2] + (directionVec[2] * extrudeLength)
                ];
                
                return {
                    id: name,
                    start: start,
                    end: end,
                    profile: profile
                };
                
            } catch (error) {
                console.error('Error extracting element data:', error);
                return null;
            }
        }

        function parseProfile(profileEntity) {
            if (profileEntity.type === 'IFCISHAPEPROFILEDEF') {
                const profileName = profileEntity.params[1]?.match(/'([^']+)'/)?.[1] || '';
                
                return {
                    type: 'I-SHAPE',
                    name: profileName,
                    overallWidth: parseFloat(profileEntity.params[3]) / 100,
                    overallDepth: parseFloat(profileEntity.params[4]) / 100,
                    webThickness: parseFloat(profileEntity.params[5]) / 100,
                    flangeThickness: parseFloat(profileEntity.params[6]) / 100,
                    filletRadius: 0
                };
            }
            return null;
        }

        function parseCoordinates(params) {
            const coords = params[0]?.match(/\(([\d\.\-E\+,]+)\)/)?.[1];
            if (!coords) return [0, 0, 0];
            return coords.split(',').map(v => parseFloat(v));
        }

        function updateUI() {
            const layersList = document.getElementById('layersList');
            layersList.innerHTML = `
                <div class="layer-item">
                    <label class="toggle-switch">
                        <input type="checkbox" checked onchange="toggleLayer('columns')">
                        <span class="slider"></span>
                    </label>
                    <span class="layer-label">Columns (${ifcData.columns.length})</span>
                </div>
                <div class="layer-item">
                    <label class="toggle-switch">
                        <input type="checkbox" checked onchange="toggleLayer('beams')">
                        <span class="slider"></span>
                    </label>
                    <span class="layer-label">Beams (${ifcData.beams.length})</span>
                </div>
                <div class="layer-item">
                    <label class="toggle-switch">
                        <input type="checkbox" checked onchange="toggleLayer('grid')">
                        <span class="slider"></span>
                    </label>
                    <span class="layer-label">Grid</span>
                </div>
            `;
            
            const aboutText = document.getElementById('aboutText');
            aboutText.textContent = `This visualization is generated directly from the IFC file (model.ifc). The structure contains ${ifcData.columns.length} columns and ${ifcData.beams.length} beams. The model is extracted and rendered in real-time using the IFC data, showing the exact positions, dimensions, and profiles specified in the BIM model.`;
            
            const stats = document.getElementById('projectStats');
            const columnProfile = ifcData.columns[0]?.profile?.name || 'N/A';
            const beamProfile = ifcData.beams[0]?.profile?.name || 'N/A';
            
            let minZ = Infinity, maxZ = -Infinity;
            ifcData.columns.forEach(col => {
                minZ = Math.min(minZ, col.start[2], col.end[2]);
                maxZ = Math.max(maxZ, col.start[2], col.end[2]);
            });
            const height = (maxZ - minZ).toFixed(2);
            
            stats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Columns</div>
                    <div class="stat-value">${ifcData.columns.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Beams</div>
                    <div class="stat-value">${ifcData.beams.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Column Profile</div>
                    <div class="stat-value">${columnProfile}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Beam Profile</div>
                    <div class="stat-value">${beamProfile}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Frame Height</div>
                    <div class="stat-value">${height}m</div>
                </div>
            `;
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function toggleCanvasBackground() {
            const container = document.getElementById('container');
            const toggle = document.getElementById('canvasBgToggle');
            
            if (toggle.checked) {
                container.classList.add('dark-canvas');
                scene.background = new THREE.Color(0x1a1a1a);
            } else {
                container.classList.remove('dark-canvas');
                scene.background = new THREE.Color(0xf8fafc);
            }
        }

        function createStars() {
            const container = document.getElementById('starsContainer');
            const numStars = 200;
            
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                const size = Math.random() * 3 + 1;
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                
                const twinkleDuration = Math.random() * 4 + 2;
                const moveDuration = Math.random() * 40 + 40;
                
                star.style.animation = `twinkle ${twinkleDuration}s linear infinite, moveStar ${moveDuration}s linear infinite`;
                
                container.appendChild(star);
            }
        }

        createStars();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8fafc);

            const container = document.getElementById('container');

            camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(12, 12, 8);
            camera.up.set(0, 0, 1);
            camera.lookAt(cameraTarget);

            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 15, 10);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-10, 10, -10);
            scene.add(directionalLight2);

            createStructureFromIFC();

            canvas.addEventListener('mouseenter', () => {
                canvasHasFocus = true;
            });
            
            canvas.addEventListener('mouseleave', () => {
                canvasHasFocus = false;
            });

            canvas.addEventListener('mousedown', (e) => {
                canvasHasFocus = true;
                onMouseDown(e);
            });

            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createIBeamShape(profile) {
            const shape = new THREE.Shape();
            
            const hw = profile.overallWidth / 2;
            const hd = profile.overallDepth / 2;
            const wt = profile.webThickness / 2;
            const ft = profile.flangeThickness;
            
            shape.moveTo(-hw, -hd);
            shape.lineTo(hw, -hd);
            shape.lineTo(hw, -hd + ft);
            shape.lineTo(wt, -hd + ft);
            
            shape.lineTo(wt, hd - ft);
            
            shape.lineTo(hw, hd - ft);
            shape.lineTo(hw, hd);
            shape.lineTo(-hw, hd);
            shape.lineTo(-hw, hd - ft);
            shape.lineTo(-wt, hd - ft);
            
            shape.lineTo(-wt, -hd + ft);
            shape.lineTo(-hw, -hd + ft);
            shape.lineTo(-hw, -hd);
            
            return shape;
        }

        function createStructureFromIFC() {
            structure = new THREE.Group();
            columnsGroup = new THREE.Group();
            beamsGroup = new THREE.Group();

            ifcData.columns.forEach((col) => {
                const start = new THREE.Vector3(col.start[0], col.start[1], col.start[2]);
                const end = new THREE.Vector3(col.end[0], col.end[1], col.end[2]);
                const length = start.distanceTo(end);
                
                const iShape = createIBeamShape(col.profile);
                
                const extrudeSettings = {
                    depth: length,
                    bevelEnabled: false
                };
                
                const geometry = new THREE.ExtrudeGeometry(iShape, extrudeSettings);
                
                const columnMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x2196F3,
                    shininess: 30
                });
                const column = new THREE.Mesh(geometry, columnMaterial);
                
                column.position.copy(start);
                
                const direction = new THREE.Vector3().subVectors(end, start).normalize();
                
                const defaultDirection = new THREE.Vector3(0, 0, 1);
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(defaultDirection, direction);
                column.setRotationFromQuaternion(quaternion);
                
                columnsGroup.add(column);
            });

            ifcData.beams.forEach((beam) => {
                const start = new THREE.Vector3(beam.start[0], beam.start[1], beam.start[2]);
                const end = new THREE.Vector3(beam.end[0], beam.end[1], beam.end[2]);
                const length = start.distanceTo(end);
                
                const iShape = createIBeamShape(beam.profile);
                
                const extrudeSettings = {
                    depth: length,
                    bevelEnabled: false
                };
                
                const geometry = new THREE.ExtrudeGeometry(iShape, extrudeSettings);
                
                const beamMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xFF9800,
                    shininess: 30
                });
                const beamMesh = new THREE.Mesh(geometry, beamMaterial);
                
                beamMesh.position.copy(start);
                
                const direction = new THREE.Vector3().subVectors(end, start).normalize();
                
                const defaultDirection = new THREE.Vector3(0, 0, 1);
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(defaultDirection, direction);
                beamMesh.setRotationFromQuaternion(quaternion);
                
                beamsGroup.add(beamMesh);
            });

            // Calculate structure bounds for grid positioning
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            ifcData.columns.forEach(col => {
                minX = Math.min(minX, col.start[0], col.end[0]);
                maxX = Math.max(maxX, col.start[0], col.end[0]);
                minY = Math.min(minY, col.start[1], col.end[1]);
                maxY = Math.max(maxY, col.start[1], col.end[1]);
            });
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            gridHelper = new THREE.GridHelper(20, 40, 0x888888, 0xcccccc);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.set(centerX, centerY, 0);

            structure.add(columnsGroup);
            structure.add(beamsGroup);
            structure.add(gridHelper);

            scene.add(structure);
        }

        function toggleLayer(layerName) {
            switch(layerName) {
                case 'columns':
                    columnsGroup.visible = !columnsGroup.visible;
                    break;
                case 'beams':
                    beamsGroup.visible = !beamsGroup.visible;
                    break;
                case 'grid':
                    gridHelper.visible = !gridHelper.visible;
                    break;
            }
        }

        function onMouseDown(e) {
            if (e.button === 0) {
                isDragging = true;
                isPanning = false;
            } else if (e.button === 2) {
                isPanning = true;
                isDragging = false;
            }
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        function onMouseMove(e) {
            if (isDragging) {
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            } else if (isPanning) {
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                const panSpeed = 0.02;
                
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                
                const cameraRight = new THREE.Vector3();
                cameraRight.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();
                
                const cameraUp = new THREE.Vector3();
                cameraUp.crossVectors(cameraRight, cameraDirection).normalize();
                
                const panX = cameraRight.clone().multiplyScalar(-deltaX * panSpeed);
                const panY = cameraUp.clone().multiplyScalar(deltaY * panSpeed);
                
                camera.position.add(panX).add(panY);
                cameraTarget.add(panX).add(panY);
                cameraPan.copy(cameraTarget);
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        }

        function onMouseUp() {
            isDragging = false;
            isPanning = false;
        }

        function onWheel(e) {
            e.preventDefault();
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((e.clientX - rect.left) / rect.width) * 2 - 1,
                -((e.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const zoomDirection = raycaster.ray.direction.clone();
            const zoomAmount = e.deltaY > 0 ? 0.5 : -0.5;
            
            camera.position.addScaledVector(zoomDirection, zoomAmount);
            cameraTarget.addScaledVector(zoomDirection, zoomAmount);
            cameraPan.copy(cameraTarget);
            
            const distance = camera.position.length();
            if (distance < 2) {
                camera.position.normalize().multiplyScalar(2);
            }
        }

        function onKeyDown(e) {
            const navKeys = ['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'space'];
            const keyLower = e.key.toLowerCase();
            const codeLower = e.code.toLowerCase();
            
            if (canvasHasFocus && (navKeys.includes(keyLower) || navKeys.includes(codeLower))) {
                e.preventDefault();
                keys[keyLower] = true;
                keys[codeLower] = true;
            } else if (!navKeys.includes(keyLower) && !navKeys.includes(codeLower)) {
                keys[keyLower] = true;
                keys[codeLower] = true;
            }
        }

        function onKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
            keys[e.code.toLowerCase()] = false;
        }

        function updateWalkMovement() {
            if (!canvasHasFocus) return;

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

            if (keys['w'] || keys['arrowup']) {
                camera.position.addScaledVector(forward, moveSpeed);
                cameraTarget.addScaledVector(forward, moveSpeed);
            }
            if (keys['s'] || keys['arrowdown']) {
                camera.position.addScaledVector(forward, -moveSpeed);
                cameraTarget.addScaledVector(forward, -moveSpeed);
            }

            if (keys['a'] || keys['arrowleft']) {
                camera.position.addScaledVector(right, -moveSpeed);
                cameraTarget.addScaledVector(right, -moveSpeed);
            }
            if (keys['d'] || keys['arrowright']) {
                camera.position.addScaledVector(right, moveSpeed);
                cameraTarget.addScaledVector(right, moveSpeed);
            }

            if (keys[' '] || keys['space']) {
                camera.position.y += verticalSpeed;
                cameraTarget.y += verticalSpeed;
            }
            if (keys['shift'] || keys['shiftleft'] || keys['shiftright']) {
                camera.position.y -= verticalSpeed;
                cameraTarget.y -= verticalSpeed;
            }

            cameraPan.copy(cameraTarget);
        }

        function onWindowResize() {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            updateWalkMovement();

            structure.rotation.y += (targetRotationY - structure.rotation.y) * 0.1;
            structure.rotation.x += (targetRotationX - structure.rotation.x) * 0.1;

            cameraTarget.x = cameraPan.x;
            cameraTarget.z = cameraPan.z;
            
            camera.lookAt(cameraTarget);

            structure.rotation.y += 0.002;

            renderer.render(scene, camera);
        }

        loadAndParseIFC();
    </script>
</body>
</html>